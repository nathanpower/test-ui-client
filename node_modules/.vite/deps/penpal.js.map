{
  "version": 3,
  "sources": ["../../.pnpm/penpal@7.0.4/node_modules/penpal/src/PenpalError.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/errorSerialization.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/Reply.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/namespace.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/guards.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/methodSerialization.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/connectCallHandler.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/generateId.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/CallOptions.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/connectRemoteProxy.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/getPromiseWithResolvers.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/PenpalBugError.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/backwardCompatibility.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/shakeHands.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/once.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/connect.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/messengers/WindowMessenger.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/messengers/WorkerMessenger.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/messengers/PortMessenger.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/ErrorCodeObj.ts", "../../.pnpm/penpal@7.0.4/node_modules/penpal/src/debug.ts"],
  "sourcesContent": ["import { ErrorCode } from './types.js';\n\nclass PenpalError extends Error {\n  public code: ErrorCode;\n\n  constructor(code: ErrorCode, message: string) {\n    super(message);\n    this.name = 'PenpalError';\n    this.code = code;\n  }\n}\n\nexport default PenpalError;\n", "import { SerializedError } from './types.js';\nimport PenpalError from './PenpalError.js';\n\n/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = (error: Error): SerializedError => ({\n  name: error.name,\n  message: error.message,\n  stack: error.stack,\n  penpalCode: error instanceof PenpalError ? error.code : undefined,\n});\n\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = ({\n  name,\n  message,\n  stack,\n  penpalCode,\n}: SerializedError): Error => {\n  const deserializedError = penpalCode\n    ? new PenpalError(penpalCode, message)\n    : new Error(message);\n\n  deserializedError.name = name;\n  deserializedError.stack = stack;\n\n  return deserializedError;\n};\n", "const brand: unique symbol = Symbol('Reply');\n\nclass Reply<T = unknown> {\n  readonly value: T;\n  readonly transferables?: Transferable[];\n\n  // Allows TypeScript to distinguish between an actual instance of this\n  // class versus an object that looks structurally similar.\n  // eslint-disable-next-line no-unused-private-class-members\n  #brand = brand;\n\n  constructor(\n    value: T,\n    options?: {\n      transferables?: Transferable[];\n    }\n  ) {\n    this.value = value;\n    this.transferables = options?.transferables;\n  }\n}\n\nexport default Reply;\n", "export default 'penpal' as const;\n", "import namespace from './namespace.js';\nimport {\n  Ack2Message,\n  CallMessage,\n  Message,\n  ReplyMessage,\n  Ack1Message,\n  SynMessage,\n  DestroyMessage,\n} from './types.js';\n\nexport const isObject = (\n  value: unknown\n): value is Record<string | number | symbol, unknown> => {\n  return typeof value === 'object' && value !== null;\n};\n\nexport const isFunction = (value: unknown) => {\n  return typeof value === 'function';\n};\n\nexport const isMessage = (data: unknown): data is Message => {\n  return isObject(data) && data.namespace === namespace;\n};\n\nexport const isSynMessage = (message: Message): message is SynMessage => {\n  return message.type === 'SYN';\n};\n\nexport const isAck1Message = (message: Message): message is Ack1Message => {\n  return message.type === 'ACK1';\n};\n\nexport const isAck2Message = (message: Message): message is Ack2Message => {\n  return message.type === 'ACK2';\n};\n\nexport const isCallMessage = (message: Message): message is CallMessage => {\n  return message.type === 'CALL';\n};\n\nexport const isReplyMessage = (message: Message): message is ReplyMessage => {\n  return message.type === 'REPLY';\n};\n\nexport const isDestroyMessage = (\n  message: Message\n): message is DestroyMessage => {\n  return message.type === 'DESTROY';\n};\n", "import { MethodPath, Methods } from './types.js';\nimport { isFunction, isObject } from './guards.js';\n\n// TODO: Used for backward-compatibility. Remove in next major version.\n/**\n * Given an object of (nested) keys to functions, extract paths to each function.\n *\n * @example\n * Given this Method object:\n * {\n *   one: {\n *     two: () => {}\n *   }\n *   three: () => {}\n * }\n *\n * the extracted MethodPath[] would be:\n * [\n *   ['one', 'two'],\n *   ['three']\n * ]\n */\nexport const extractMethodPathsFromMethods = (\n  methods: Methods,\n  currentPath: MethodPath = []\n) => {\n  const methodPaths: MethodPath[] = [];\n\n  for (const key of Object.keys(methods)) {\n    const value = methods[key];\n\n    if (isFunction(value)) {\n      methodPaths.push([...currentPath, key]);\n    } else if (isObject(value)) {\n      methodPaths.push(\n        ...extractMethodPathsFromMethods(value, [...currentPath, key])\n      );\n    }\n  }\n\n  return methodPaths;\n};\n\nexport const getMethodAtMethodPath = (\n  methodPath: MethodPath,\n  methods: Methods\n) => {\n  const result = methodPath.reduce<Methods | Function | undefined>(\n    (acc, pathSegment) => {\n      return isObject(acc) ? acc[pathSegment] : undefined;\n    },\n    methods\n  );\n\n  return isFunction(result) ? result : undefined;\n};\n\nexport const formatMethodPath = (methodPath: MethodPath) => {\n  return methodPath.join('.');\n};\n", "import { serializeError } from './errorSerialization.js';\nimport { Message, ReplyMessage, Methods, Log } from './types.js';\nimport Reply from './Reply.js';\nimport Messenger from './messengers/Messenger.js';\nimport PenpalError from './PenpalError.js';\nimport {\n  formatMethodPath,\n  getMethodAtMethodPath,\n} from './methodSerialization.js';\nimport { isCallMessage } from './guards.js';\nimport namespace from './namespace.js';\n\nconst createErrorReplyMessage = (\n  channel: string | undefined,\n  callId: string,\n  error: unknown\n): ReplyMessage => ({\n  namespace,\n  channel,\n  type: 'REPLY',\n  callId,\n  isError: true,\n  ...(error instanceof Error\n    ? { value: serializeError(error), isSerializedErrorInstance: true }\n    : { value: error }),\n});\n\n/**\n * Listens for \"call\" messages from the remote, executes the corresponding method,\n * and responds with the return value or error.\n */\nconst connectCallHandler = (\n  messenger: Messenger,\n  methods: Methods,\n  channel: string | undefined,\n  log: Log | undefined\n) => {\n  let isDestroyed = false;\n\n  const handleMessage = async (message: Message) => {\n    if (isDestroyed) {\n      // It's possible to throw an error here, but it would only be catchable\n      // using window.onerror since we're in an asynchronously-called function.\n      // There is no method call the consumer is making that they could wrap in\n      // a try-catch. Even if the consumer were to catch the error somehow,\n      // the value of doing so is questionable.\n      return;\n    }\n\n    if (!isCallMessage(message)) {\n      return;\n    }\n\n    log?.(`Received ${formatMethodPath(message.methodPath)}() call`, message);\n\n    const { methodPath, args, id: callId } = message;\n    let replyMessage: ReplyMessage;\n    let transferables: Transferable[] | undefined;\n\n    try {\n      const method = getMethodAtMethodPath(methodPath, methods);\n\n      if (!method) {\n        throw new PenpalError(\n          'METHOD_NOT_FOUND',\n          `Method \\`${formatMethodPath(methodPath)}\\` is not found.`\n        );\n      }\n\n      let value: unknown = await method(...args);\n\n      if (value instanceof Reply) {\n        transferables = value.transferables;\n        value = await value.value;\n      }\n\n      replyMessage = {\n        namespace,\n        channel,\n        type: 'REPLY',\n        callId,\n        value,\n      };\n    } catch (error) {\n      replyMessage = createErrorReplyMessage(channel, callId, error);\n    }\n\n    // Although we checked this at the beginning of the function, we need to\n    // check it again because we've made async calls, and the connection may\n    // have been destroyed in the meantime.\n    if (isDestroyed) {\n      return;\n    }\n\n    try {\n      log?.(`Sending ${formatMethodPath(methodPath)}() reply`, replyMessage);\n      messenger.sendMessage(replyMessage, transferables);\n    } catch (error) {\n      // If a consumer attempts to send an object that's not\n      // cloneable (e.g., window), we want to ensure the receiver's promise\n      // gets rejected.\n      if ((error as Error).name === 'DataCloneError') {\n        replyMessage = createErrorReplyMessage(channel, callId, error as Error);\n        log?.(`Sending ${formatMethodPath(methodPath)}() reply`, replyMessage);\n        messenger.sendMessage(replyMessage);\n      }\n      throw error;\n    }\n  };\n\n  messenger.addMessageHandler(handleMessage);\n\n  return () => {\n    isDestroyed = true;\n    messenger.removeMessageHandler(handleMessage);\n  };\n};\n\nexport default connectCallHandler;\n", "/**\n * @return A unique ID\n */\n// crypto.randomUUID is not available in insecure contexts.\nexport default crypto.randomUUID?.bind(crypto) ??\n  (() =>\n    new Array(4)\n      .fill(0)\n      .map(() =>\n        Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)\n      )\n      .join('-'));\n", "const brand: unique symbol = Symbol('CallOptions');\n\nclass CallOptions {\n  readonly transferables?: Transferable[];\n  readonly timeout?: number;\n\n  // Allows TypeScript to distinguish between an actual instance of this\n  // class versus an object that looks structurally similar.\n  // eslint-disable-next-line no-unused-private-class-members\n  #brand = brand;\n\n  constructor(options?: { transferables?: Transferable[]; timeout?: number }) {\n    this.transferables = options?.transferables;\n    this.timeout = options?.timeout;\n  }\n}\n\nexport default CallOptions;\n", "import generateId from './generateId.js';\nimport { deserializeError } from './errorSerialization.js';\nimport { formatMethodPath } from './methodSerialization.js';\nimport {\n  Message,\n  RemoteProxy,\n  Methods,\n  MethodPath,\n  CallMessage,\n  Log,\n} from './types.js';\nimport CallOptions from './CallOptions.js';\nimport Messenger from './messengers/Messenger.js';\nimport PenpalError from './PenpalError.js';\nimport { isReplyMessage } from './guards.js';\nimport namespace from './namespace.js';\n\ntype ReplyHandler = {\n  methodPath: MethodPath;\n  resolve: (value: unknown) => void;\n  reject: (reason: unknown) => void;\n  timeoutId?: number;\n};\n\nconst methodsToTreatAsNative = new Set(['apply', 'call', 'bind']);\n\nconst createRemoteProxy = (\n  callback: (path: MethodPath, args: unknown[]) => void,\n  log?: Log,\n  path: MethodPath = []\n): Methods => {\n  return new Proxy(\n    path.length\n      ? () => {\n          // Intentionally empty\n        }\n      : Object.create(null),\n    {\n      get(target, prop: string) {\n        // If a promise is resolved with this proxy object, the JavaScript\n        // runtime will look for a `then` property on this object to determine\n        // if it should be treated as a promise (to support promise chaining).\n        // If we don't return undefined here, the JavaScript runtime will treat\n        // this object as a promise and attempt to call `then`, which will\n        // then send a call message to the remote. This is not what we want.\n        if (prop === 'then') {\n          return;\n        }\n\n        // Because we're using a proxy and because Penpal supports developers\n        // exposing nested methods, we have a predicament. If a developer\n        // calls, for example, remote.auth.apply(), are they\n        // attempting to call a nested apply() method that a developer has\n        // explicitly exposed from the remote? Could they instead be attempting\n        // to call Function.prototype.apply() on the remote.auth() method?\n        // Without the remote telling the local Penpal which methods the\n        // developer has exposed, it has no way of knowing (and the main reason\n        // we use a proxy is so that Penpal doesn't have to communicate which\n        // methods are exposed). So, we treat certain methods as native methods\n        // and return the native method rather than a proxy. The downside of\n        // this is that if a developer has explicitly exposed a nested method\n        // with the same name as one of these native method names, the developer\n        // will be unable to call the exposed remote method because they will\n        // be calling the method on the Function prototype instead.\n        if (path.length && methodsToTreatAsNative.has(prop)) {\n          return Reflect.get(target, prop);\n        }\n\n        return createRemoteProxy(callback, log, [...path, prop]);\n      },\n      apply(target, _thisArg, args) {\n        return callback(path, args);\n      },\n    }\n  );\n};\n\nconst getDestroyedConnectionMethodCallError = (methodPath: MethodPath) => {\n  return new PenpalError(\n    'CONNECTION_DESTROYED',\n    `Method call ${formatMethodPath(\n      methodPath\n    )}() failed due to destroyed connection`\n  );\n};\n\n/**\n * Creates a proxy. When methods are called on the proxy, a \"call\" message will\n * be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n */\nconst connectRemoteProxy = <TMethods extends Methods>(\n  messenger: Messenger,\n  channel: string | undefined,\n  log: Log | undefined\n) => {\n  let isDestroyed = false;\n  const replyHandlers = new Map<string, ReplyHandler>();\n\n  const handleMessage = (message: Message) => {\n    if (!isReplyMessage(message)) {\n      return;\n    }\n\n    const { callId, value, isError, isSerializedErrorInstance } = message;\n    const replyHandler = replyHandlers.get(callId);\n\n    if (!replyHandler) {\n      return;\n    }\n\n    replyHandlers.delete(callId);\n    log?.(\n      `Received ${formatMethodPath(replyHandler.methodPath)}() call`,\n      message\n    );\n\n    if (isError) {\n      replyHandler.reject(\n        isSerializedErrorInstance ? deserializeError(value) : value\n      );\n    } else {\n      replyHandler.resolve(value);\n    }\n  };\n\n  messenger.addMessageHandler(handleMessage);\n\n  const remoteProxy = createRemoteProxy((methodPath, args) => {\n    if (isDestroyed) {\n      throw getDestroyedConnectionMethodCallError(methodPath);\n    }\n\n    const callId = generateId();\n    const lastArg = args[args.length - 1];\n    const lastArgIsOptions = lastArg instanceof CallOptions;\n    const { timeout, transferables } = lastArgIsOptions ? lastArg : {};\n    const argsWithoutOptions = lastArgIsOptions ? args.slice(0, -1) : args;\n\n    return new Promise((resolve, reject) => {\n      // We reference `window.setTimeout` instead of just `setTimeout`\n      // so that the TypeScript engine doesn't\n      // get confused when running tests. Something within\n      // Karma + @rollup/plugin-typescript leaks node types into source\n      // files when running tests. Node's setTimeout has a return type of\n      // Timeout rather than number, resulting in a build error when\n      // running tests if we don't disambiguate the browser setTimeout\n      // from node's setTimeout. There may be a better way to configure\n      // Karma + Rollup + Typescript to avoid node type leakage.\n      const timeoutId =\n        timeout !== undefined\n          ? window.setTimeout(() => {\n              replyHandlers.delete(callId);\n              reject(\n                new PenpalError(\n                  'METHOD_CALL_TIMEOUT',\n                  `Method call ${formatMethodPath(\n                    methodPath\n                  )}() timed out after ${timeout}ms`\n                )\n              );\n            }, timeout)\n          : undefined;\n\n      replyHandlers.set(callId, { methodPath, resolve, reject, timeoutId });\n\n      try {\n        const callMessage: CallMessage = {\n          namespace,\n          channel,\n          type: 'CALL',\n          id: callId,\n          methodPath,\n          args: argsWithoutOptions,\n        };\n        log?.(`Sending ${formatMethodPath(methodPath)}() call`, callMessage);\n        messenger.sendMessage(callMessage, transferables);\n      } catch (error) {\n        reject(\n          new PenpalError('TRANSMISSION_FAILED', (error as Error).message)\n        );\n      }\n    });\n  }, log) as RemoteProxy<TMethods>;\n\n  const destroy = () => {\n    isDestroyed = true;\n    messenger.removeMessageHandler(handleMessage);\n\n    for (const { methodPath, reject, timeoutId } of replyHandlers.values()) {\n      clearTimeout(timeoutId);\n      reject(getDestroyedConnectionMethodCallError(methodPath));\n    }\n\n    replyHandlers.clear();\n  };\n\n  return {\n    remoteProxy,\n    destroy,\n  };\n};\n\nexport default connectRemoteProxy;\n", "// Just use the native Promise.withResolvers() once it gains a bit more\n// adoption. Safari was the last major browser to support it, which happened\n// on March 5, 2024 in Safari 17.4.\nconst getPromiseWithResolvers = <ResolvedValueType, RejectedValueType>() => {\n  let resolve: (value: ResolvedValueType) => void;\n  let reject: (error: RejectedValueType) => void;\n\n  const promise = new Promise<ResolvedValueType>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n};\n\nexport default getPromiseWithResolvers;\n", "/**\n * Error class that is thrown when we've reached a situation that we believe to\n * be a bug in Penpal and not anything the consumer has done.\n */\nclass PenpalBugError extends Error {\n  constructor(message: string) {\n    super(\n      `You've hit a bug in Penpal. Please file an issue with the following information: ${message}`\n    );\n  }\n}\n\nexport default PenpalBugError;\n", "import { Message, MethodPath } from './types.js';\nimport namespace from './namespace.js';\nimport {\n  isCallMessage,\n  isReplyMessage,\n  isAck1Message,\n  isObject,\n} from './guards.js';\nimport PenpalBugError from './PenpalBugError.js';\n\nexport const DEPRECATED_PENPAL_PARTICIPANT_ID = 'deprecated-penpal';\n\n// TODO: This file is used for backward-compatibility. Remove in next major version.\n\nenum DeprecatedMessageType {\n  Call = 'call',\n  Reply = 'reply',\n  Syn = 'syn',\n  SynAck = 'synAck',\n  Ack = 'ack',\n}\n\nenum DeprecatedResolution {\n  Fulfilled = 'fulfilled',\n  Rejected = 'rejected',\n}\n\ntype DeprecatedSynMessage = {\n  penpal: DeprecatedMessageType.Syn;\n};\n\ntype DeprecatedSynAckMessage = {\n  penpal: DeprecatedMessageType.SynAck;\n  methodNames: string[];\n};\n\ntype DeprecatedAckMessage = {\n  penpal: DeprecatedMessageType.Ack;\n  methodNames: string[];\n};\n\ntype DeprecatedCallMessage = {\n  penpal: DeprecatedMessageType.Call;\n  id: number;\n  methodName: string;\n  args: unknown[];\n};\n\ntype DeprecatedSerializedError = {\n  name: string;\n  message: string;\n  stack?: string;\n};\n\ntype DeprecatedReplyMessage = {\n  penpal: DeprecatedMessageType.Reply;\n  id: number;\n} & (\n  | {\n      resolution: DeprecatedResolution.Fulfilled;\n      returnValue: unknown;\n      returnValueIsError?: false;\n    }\n  | {\n      resolution: DeprecatedResolution.Rejected;\n      returnValue: unknown;\n      returnValueIsError?: false;\n    }\n  | {\n      resolution: DeprecatedResolution.Rejected;\n      returnValue: DeprecatedSerializedError;\n      returnValueIsError: true;\n    }\n);\n\nexport type DeprecatedMessage =\n  | DeprecatedSynMessage\n  | DeprecatedSynAckMessage\n  | DeprecatedAckMessage\n  | DeprecatedCallMessage\n  | DeprecatedReplyMessage;\n\nexport const isDeprecatedMessage = (\n  data: unknown\n): data is DeprecatedMessage => {\n  return isObject(data) && 'penpal' in data;\n};\n\nconst upgradeMethodPath = (methodPath: string): MethodPath =>\n  methodPath.split('.');\nconst downgradeMethodPath = (methodPath: MethodPath) => methodPath.join('.');\n\nconst getUnexpectedMessageError = (message: unknown) => {\n  return new PenpalBugError(\n    `Unexpected message to translate: ${JSON.stringify(message)}`\n  );\n};\n\nexport const upgradeMessage = (message: DeprecatedMessage): Message => {\n  if (message.penpal === DeprecatedMessageType.Syn) {\n    return {\n      namespace,\n      channel: undefined,\n      type: 'SYN',\n      participantId: DEPRECATED_PENPAL_PARTICIPANT_ID,\n    };\n  }\n\n  if (message.penpal === DeprecatedMessageType.Ack) {\n    return {\n      namespace,\n      channel: undefined,\n      type: 'ACK2',\n    };\n  }\n\n  if (message.penpal === DeprecatedMessageType.Call) {\n    return {\n      namespace,\n      channel: undefined,\n      type: 'CALL',\n      // Actually converting the ID to a string would break communication.\n      id: (message.id as unknown) as string,\n      methodPath: upgradeMethodPath(message.methodName),\n      args: message.args,\n    };\n  }\n\n  if (message.penpal === DeprecatedMessageType.Reply) {\n    if (message.resolution === DeprecatedResolution.Fulfilled) {\n      return {\n        namespace,\n        channel: undefined,\n        type: 'REPLY',\n        // Actually converting the ID to a string would break communication.\n        callId: (message.id as unknown) as string,\n        value: message.returnValue,\n      };\n    } else {\n      return {\n        namespace,\n        channel: undefined,\n        type: 'REPLY',\n        // Actually converting the ID to a string would break communication.\n        callId: (message.id as unknown) as string,\n        isError: true,\n        ...(message.returnValueIsError\n          ? {\n              value: message.returnValue,\n              isSerializedErrorInstance: true,\n            }\n          : {\n              value: message.returnValue,\n            }),\n      };\n    }\n  }\n\n  throw getUnexpectedMessageError(message);\n};\n\nexport const downgradeMessage = (message: Message): DeprecatedMessage => {\n  if (isAck1Message(message)) {\n    return {\n      penpal: DeprecatedMessageType.SynAck,\n      methodNames: message.methodPaths.map(downgradeMethodPath),\n    };\n  }\n\n  if (isCallMessage(message)) {\n    return {\n      penpal: DeprecatedMessageType.Call,\n      // Actually converting the ID to a number would break communication.\n      id: (message.id as unknown) as number,\n      methodName: downgradeMethodPath(message.methodPath),\n      args: message.args,\n    };\n  }\n\n  if (isReplyMessage(message)) {\n    if (message.isError) {\n      return {\n        penpal: DeprecatedMessageType.Reply,\n        // Actually converting the ID to a number would break communication.\n        id: (message.callId as unknown) as number,\n        resolution: DeprecatedResolution.Rejected,\n        ...(message.isSerializedErrorInstance\n          ? {\n              returnValue: message.value,\n              returnValueIsError: true,\n            }\n          : { returnValue: message.value }),\n      };\n    } else {\n      return {\n        penpal: DeprecatedMessageType.Reply,\n        // Actually converting the ID to a number would break communication.\n        id: (message.callId as unknown) as number,\n        resolution: DeprecatedResolution.Fulfilled,\n        returnValue: message.value,\n      };\n    }\n  }\n\n  throw getUnexpectedMessageError(message);\n};\n", "import Messenger from './messengers/Messenger.js';\nimport {\n  Ack2Message,\n  Methods,\n  Message,\n  RemoteProxy,\n  Ack1Message,\n  SynMessage,\n  Log,\n} from './types.js';\nimport PenpalError from './PenpalError.js';\nimport connectCallHandler from './connectCallHandler.js';\nimport connectRemoteProxy from './connectRemoteProxy.js';\nimport { isAck2Message, isAck1Message, isSynMessage } from './guards.js';\nimport getPromiseWithResolvers from './getPromiseWithResolvers.js';\nimport { extractMethodPathsFromMethods } from './methodSerialization.js';\nimport generateId from './generateId.js';\nimport { DEPRECATED_PENPAL_PARTICIPANT_ID } from './backwardCompatibility.js';\nimport namespace from './namespace.js';\n\ntype Options = {\n  messenger: Messenger;\n  methods: Methods;\n  timeout: number | undefined;\n  channel: string | undefined;\n  log: Log | undefined;\n};\n\ntype HandshakeResult<TMethods extends Methods> = {\n  remoteProxy: RemoteProxy<TMethods>;\n  destroy: () => void;\n};\n\n/**\n * Attempts to establish communication with the remote via a handshake protocol.\n * The handshake protocol fulfills a few requirements:\n *\n * 1. One participant in the handshake may not be available when the other\n *    participant starts the handshake. For example, a document inside an iframe\n *    may not be loaded when the parent window starts a handshake.\n * 2. While #1 could be solved by having the consumer of Penpal specify which\n *    participant should initiate the handshake, we'd rather avoid this\n *    unnecessary cognitive load.\n * 3. While #1 could be solved by having the consumer of Penpal specify which\n *    participant is the \"parent\" or \"child\" and then having Penpal assume\n *    the child should initiate the handshake, we'd rather avoid parent-child\n *    terminology since Penpal can support communication between two\n *    participants where neither would be considered a parent nor child. It may\n *    also be too presumptive that the child should always initiate the\n *    handshake.\n * 4. For robustness, each participant must know that the other participant is\n *    receiving its messages for the handshake to be considered complete.\n * 5. The handshake should support a participant attempting to\n *    re-establish the connection. This can occur, for example, if an end user\n *    were to right-click within an iframe and click reload.\n * 6. The handshake should allow a Messenger to easily attach something to\n *    a handshake message from one participant to the other unidirectionally\n *    (rather than from both participants to each other).\n *    This is important when a participant needs to be in charge of, for\n *    example, creating a MessageChannel and sending one MessagePort from the\n *    MessagePort pair to the other participant. If both participants attempted\n *    to do this it could lead to confusion.\n * 7. The handshake ideally shouldn't require sending handshake messages on an\n *    interval (retrying until the other participant is ready to receive them).\n *    Intervals can increase compute resources if the interval is too short\n *    or increase latency if the interval is too long. While we could make this\n *    configurable, it's additional mental load for the consumer. Additionally,\n *    setInterval and setTimeout are not available within some contexts\n *    (like AudioWorklet), where a consumer may like to use Penpal.\n *\n * To accomplish these requirements, the handshake protocol is as follows:\n * 1. Each participant generates a random participant ID.\n * 2. As soon as possible, each participant sends a SYN message containing its\n *    participant ID to the other participant.\n * 3. When the SYN messages were sent, one of the participants may not have\n *    been ready to receive the SYN message from the other. At least one\n *    of the participants was ready, however, and should have received a SYN\n *    message from the other participant. Each participant that did receive\n *    a SYN message knows for sure that the other participant is now ready\n *    to receive a SYN message, so it will send another SYN message in case\n *    the other participant did not receive the first SYN message. This\n *    ultimately results in each participant sending two SYN messages.\n * 4. Each participant now should have received at least one SYN message from\n *    the other participant. Each participant compares their own ID with the\n *    other participant's ID. Whichever participant has the higher ID\n *    (using a simple string comparison) is considered the handshake leader\n *    and will send an ACK1 message to the other participant.\n * 5. At this point, the handshake leader does not know whether the other\n *    participant is actually receiving messages. The participant receiving\n *    the ACK1 message will respond with an ACK2, informing the handshake\n *    leader that it is indeed receiving messages.\n * 6. At this point, both participants know the other is receiving messages\n *    and the handshake is complete.\n */\nconst shakeHands = <TMethods extends Methods>({\n  messenger,\n  methods,\n  timeout,\n  channel,\n  log,\n}: Options): Promise<HandshakeResult<TMethods>> => {\n  const participantId = generateId();\n  let remoteParticipantId: string;\n  const destroyHandlers: (() => void)[] = [];\n  let isComplete = false;\n\n  const methodPaths = extractMethodPathsFromMethods(methods);\n\n  const { promise, resolve, reject } = getPromiseWithResolvers<\n    HandshakeResult<TMethods>,\n    PenpalError\n  >();\n\n  const timeoutId =\n    timeout !== undefined\n      ? setTimeout(() => {\n          reject(\n            new PenpalError(\n              'CONNECTION_TIMEOUT',\n              `Connection timed out after ${timeout}ms`\n            )\n          );\n        }, timeout)\n      : undefined;\n\n  const destroy = () => {\n    for (const destroyHandler of destroyHandlers) {\n      destroyHandler();\n    }\n  };\n\n  const connectCallHandlerAndMethodProxies = () => {\n    if (isComplete) {\n      // If we get here, it means the remote is attempting to re-connect. While\n      // that's supported, we don't need to run the rest of this function again.\n      return;\n    }\n\n    destroyHandlers.push(connectCallHandler(messenger, methods, channel, log));\n\n    const { remoteProxy, destroy: destroyMethodProxies } = connectRemoteProxy<\n      TMethods\n    >(messenger, channel, log);\n\n    destroyHandlers.push(destroyMethodProxies);\n\n    clearTimeout(timeoutId);\n    isComplete = true;\n\n    resolve({\n      remoteProxy,\n      destroy: destroy,\n    });\n  };\n\n  const sendSynMessage = () => {\n    const synMessage: SynMessage = {\n      namespace,\n      type: 'SYN',\n      channel,\n      participantId: participantId,\n    };\n    log?.(`Sending handshake SYN`, synMessage);\n\n    try {\n      messenger.sendMessage(synMessage);\n    } catch (error) {\n      reject(new PenpalError('TRANSMISSION_FAILED', (error as Error).message));\n    }\n  };\n\n  const handleSynMessage = (message: SynMessage) => {\n    log?.(`Received handshake SYN`, message);\n\n    if (\n      message.participantId === remoteParticipantId &&\n      // TODO: Used for backward-compatibility. Remove in next major version.\n      remoteParticipantId !== DEPRECATED_PENPAL_PARTICIPANT_ID\n    ) {\n      return;\n    }\n\n    remoteParticipantId = message.participantId;\n\n    // We send another SYN message in case the other participant was not ready\n    // when we sent the first SYN message.\n    sendSynMessage();\n\n    const isHandshakeLeader =\n      participantId > remoteParticipantId ||\n      // TODO: Used for backward-compatibility. Remove in next major version.\n      remoteParticipantId === DEPRECATED_PENPAL_PARTICIPANT_ID;\n\n    if (!isHandshakeLeader) {\n      return;\n    }\n\n    const ack1Message: Ack1Message = {\n      namespace,\n      channel,\n      type: 'ACK1',\n      methodPaths,\n    };\n    log?.(`Sending handshake ACK1`, ack1Message);\n\n    try {\n      messenger.sendMessage(ack1Message);\n    } catch (error) {\n      reject(new PenpalError('TRANSMISSION_FAILED', (error as Error).message));\n      return;\n    }\n  };\n\n  const handleAck1Message = (message: Ack1Message) => {\n    log?.(`Received handshake ACK1`, message);\n    const ack2Message: Ack2Message = {\n      namespace,\n      channel,\n      type: 'ACK2',\n    };\n    log?.(`Sending handshake ACK2`, ack2Message);\n\n    try {\n      messenger.sendMessage(ack2Message);\n    } catch (error) {\n      reject(new PenpalError('TRANSMISSION_FAILED', (error as Error).message));\n      return;\n    }\n\n    connectCallHandlerAndMethodProxies();\n  };\n\n  const handleAck2Message = (message: Ack2Message) => {\n    log?.(`Received handshake ACK2`, message);\n    connectCallHandlerAndMethodProxies();\n  };\n\n  const handleMessage = (message: Message) => {\n    if (isSynMessage(message)) {\n      handleSynMessage(message);\n    }\n\n    if (isAck1Message(message)) {\n      handleAck1Message(message);\n    }\n\n    if (isAck2Message(message)) {\n      handleAck2Message(message);\n    }\n  };\n\n  messenger.addMessageHandler(handleMessage);\n  destroyHandlers.push(() => messenger.removeMessageHandler(handleMessage));\n\n  sendSynMessage();\n\n  return promise;\n};\n\nexport default shakeHands;\n", "// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst once = <T extends (...args: any[]) => any>(\n  fn: T\n): ((...args: Parameters<T>) => ReturnType<T>) => {\n  let isCalled = false;\n  let result: ReturnType<T>;\n\n  return (...args: Parameters<T>): ReturnType<T> => {\n    if (!isCalled) {\n      isCalled = true;\n      result = fn(...args);\n    }\n    return result;\n  };\n};\n\nexport default once;\n", "import { DestroyMessage, Connection, Log, Message, Methods } from './types.js';\nimport PenpalError from './PenpalError.js';\nimport Messenger from './messengers/Messenger.js';\nimport shakeHands from './shakeHands.js';\nimport { isDestroyMessage, isMessage } from './guards.js';\nimport once from './once.js';\nimport namespace from './namespace.js';\n\ntype Options = {\n  /**\n   * Messenger in charge of handling communication with the remote.\n   */\n  messenger: Messenger;\n  /**\n   * Methods that may be called by the remote.\n   */\n  methods?: Methods;\n  /**\n   * The amount of time, in milliseconds, Penpal should wait\n   * for a connection to be established before rejecting the connection promise.\n   */\n  timeout?: number;\n  /**\n   * A string identifier that disambiguates communication when establishing\n   * multiple, parallel connections between two participants (e.g., two windows,\n   * a window and a worker).\n   */\n  channel?: string;\n  /**\n   * A function for logging debug messages. Debug messages will only be\n   * logged when this is defined.\n   */\n  log?: Log;\n};\n\nconst usedMessengers = new WeakSet<Messenger>();\n\n/**\n * Attempts to establish communication with the remote.\n */\nconst connect = <TMethods extends Methods>({\n  messenger,\n  methods = {},\n  timeout,\n  channel,\n  log,\n}: Options): Connection<TMethods> => {\n  if (!messenger) {\n    throw new PenpalError('INVALID_ARGUMENT', 'messenger must be defined');\n  }\n\n  if (usedMessengers.has(messenger)) {\n    throw new PenpalError(\n      'INVALID_ARGUMENT',\n      'A messenger can only be used for a single connection'\n    );\n  }\n\n  usedMessengers.add(messenger);\n\n  const connectionDestroyedHandlers: (() => void)[] = [messenger.destroy];\n\n  const destroyConnection = once((notifyOtherParticipant: boolean) => {\n    if (notifyOtherParticipant) {\n      const destroyMessage: DestroyMessage = {\n        namespace,\n        channel,\n        type: 'DESTROY',\n      };\n\n      try {\n        messenger.sendMessage(destroyMessage);\n      } catch (_) {\n        // We do our best to notify the other participant of the connection, but\n        // if there's an error in doing so (e.g., maybe the handshake hasn't\n        // completed and a messenger can't send the message), it's probably not\n        // worth bothering the consumer with an error.\n      }\n    }\n\n    for (const connectionDestroyedHandler of connectionDestroyedHandlers) {\n      connectionDestroyedHandler();\n    }\n\n    log?.('Connection destroyed');\n  });\n\n  const validateReceivedMessage = (data: unknown): data is Message => {\n    return isMessage(data) && data.channel === channel;\n  };\n\n  const promise = (async () => {\n    try {\n      messenger.initialize({ log, validateReceivedMessage });\n      messenger.addMessageHandler((message) => {\n        if (isDestroyMessage(message)) {\n          destroyConnection(false);\n        }\n      });\n\n      const { remoteProxy, destroy } = await shakeHands<TMethods>({\n        messenger,\n        methods,\n        timeout,\n        channel,\n        log,\n      });\n      connectionDestroyedHandlers.push(destroy);\n      return remoteProxy;\n    } catch (error) {\n      destroyConnection(true);\n      throw error as PenpalError;\n    }\n  })();\n\n  return {\n    promise,\n    // Why we don't reject the connection promise when consumer calls destroy():\n    // https://github.com/Aaronius/penpal/issues/51\n    destroy: () => {\n      destroyConnection(true);\n    },\n  };\n};\n\nexport default connect;\n", "import { Log, Message } from '../types.js';\nimport Messenger, {\n  InitializeMessengerOptions,\n  MessageHandler,\n} from './Messenger.js';\nimport {\n  downgradeMessage,\n  isDeprecatedMessage,\n  upgradeMessage,\n} from '../backwardCompatibility.js';\nimport { isAck2Message, isAck1Message, isSynMessage } from '../guards.js';\nimport PenpalError from '../PenpalError.js';\nimport PenpalBugError from '../PenpalBugError.js';\n\ntype Options = {\n  /**\n   * The window with which the current window will communicate.\n   */\n  remoteWindow: Window;\n  /**\n   * An array of strings or regular expressions defining to which origins\n   * communication will be allowed. If not provided, communication will be\n   * restricted to the origin of the current page. You may specify an allowed\n   * origin of `*` to not restrict communication, but beware the risks of\n   * doing so.\n   */\n  allowedOrigins?: (string | RegExp)[];\n};\n\n/**\n * Handles the details of communicating with a child window.\n */\nclass WindowMessenger implements Messenger {\n  readonly #remoteWindow: Window;\n  readonly #allowedOrigins: [string | RegExp, ...(string | RegExp)[]];\n  #log?: Log;\n  #validateReceivedMessage?: (data: unknown) => data is Message;\n  #concreteRemoteOrigin?: string;\n  #messageCallbacks = new Set<(message: Message) => void>();\n  #port?: MessagePort;\n  // TODO: Used for backward-compatibility. Remove in next major version.\n  #isChildUsingDeprecatedProtocol = false;\n\n  constructor({ remoteWindow, allowedOrigins }: Options) {\n    if (!remoteWindow) {\n      throw new PenpalError('INVALID_ARGUMENT', 'remoteWindow must be defined');\n    }\n\n    this.#remoteWindow = remoteWindow;\n    this.#allowedOrigins = allowedOrigins?.length\n      ? (allowedOrigins as [string | RegExp, ...(string | RegExp)[]])\n      : [window.origin];\n  }\n\n  initialize = ({\n    log,\n    validateReceivedMessage,\n  }: InitializeMessengerOptions) => {\n    this.#log = log;\n    this.#validateReceivedMessage = validateReceivedMessage;\n    window.addEventListener('message', this.#handleMessageFromRemoteWindow);\n  };\n\n  sendMessage = (message: Message, transferables?: Transferable[]): void => {\n    if (isSynMessage(message)) {\n      const originForSending = this.#getOriginForSendingMessage(message);\n      this.#remoteWindow.postMessage(message, {\n        targetOrigin: originForSending,\n        transfer: transferables,\n      });\n      return;\n    }\n\n    if (\n      isAck1Message(message) ||\n      // If the child is using a previous version of Penpal, we need to\n      // downgrade the message and send it through the window rather than\n      // the port because older versions of Penpal don't use MessagePorts.\n      this.#isChildUsingDeprecatedProtocol\n    ) {\n      const payload = this.#isChildUsingDeprecatedProtocol\n        ? downgradeMessage(message)\n        : message;\n      const originForSending = this.#getOriginForSendingMessage(message);\n      this.#remoteWindow.postMessage(payload, {\n        targetOrigin: originForSending,\n        transfer: transferables,\n      });\n      return;\n    }\n\n    if (isAck2Message(message)) {\n      const { port1, port2 } = new MessageChannel();\n      this.#port = port1;\n      port1.addEventListener('message', this.#handleMessageFromPort);\n      port1.start();\n      const transferablesToSend = [port2, ...(transferables || [])];\n      const originForSending = this.#getOriginForSendingMessage(message);\n      this.#remoteWindow.postMessage(message, {\n        targetOrigin: originForSending,\n        transfer: transferablesToSend,\n      });\n      return;\n    }\n\n    if (this.#port) {\n      this.#port.postMessage(message, {\n        transfer: transferables,\n      });\n      return;\n    }\n\n    throw new PenpalBugError('Port is undefined');\n  };\n\n  addMessageHandler = (callback: MessageHandler): void => {\n    this.#messageCallbacks.add(callback);\n  };\n\n  removeMessageHandler = (callback: MessageHandler): void => {\n    this.#messageCallbacks.delete(callback);\n  };\n\n  destroy = () => {\n    window.removeEventListener('message', this.#handleMessageFromRemoteWindow);\n    this.#destroyPort();\n    this.#messageCallbacks.clear();\n  };\n\n  #isAllowedOrigin = (origin: string) => {\n    return this.#allowedOrigins.some((allowedOrigin) =>\n      allowedOrigin instanceof RegExp\n        ? allowedOrigin.test(origin)\n        : allowedOrigin === origin || allowedOrigin === '*'\n    );\n  };\n\n  #getOriginForSendingMessage = (message: Message) => {\n    // It's safe to send the SYN message to any origin because it doesn't contain\n    // anything sensitive. When Penpal receives a SYN message, the origin on\n    // the message (which we call the concrete origin) is validated against the\n    // configured allowed origins. All subsequent messages will be sent to the\n    // concrete origin.\n    // If you decide to change this, consider https://github.com/Aaronius/penpal/issues/103\n    if (isSynMessage(message)) {\n      return '*';\n    }\n\n    if (!this.#concreteRemoteOrigin) {\n      throw new PenpalBugError('Concrete remote origin not set');\n    }\n\n    // If the concrete remote origin (the origin we received from the remote\n    // on a prior message) is 'null', it means the remote is within\n    // an \"opaque origin\". The only way to post a message to an\n    // opaque origin is by using '*'. This does carry some security risk,\n    // so we only do this if the consumer has specifically defined '*' as\n    // an allowed origin. Opaque origins occur, for example, when\n    // loading an HTML document directly from the filesystem (not a\n    // web server) or through a data URI.\n    return this.#concreteRemoteOrigin === 'null' &&\n      this.#allowedOrigins.includes('*')\n      ? '*'\n      : this.#concreteRemoteOrigin;\n  };\n\n  #destroyPort = () => {\n    this.#port?.removeEventListener('message', this.#handleMessageFromPort);\n    this.#port?.close();\n    this.#port = undefined;\n  };\n\n  #handleMessageFromRemoteWindow = ({\n    source,\n    origin,\n    ports,\n    data,\n  }: MessageEvent): void => {\n    if (source !== this.#remoteWindow) {\n      return;\n    }\n\n    // TODO: Used for backward-compatibility. Remove in next major version.\n    if (isDeprecatedMessage(data)) {\n      this.#log?.(\n        'Please upgrade the child window to the latest version of Penpal.'\n      );\n      this.#isChildUsingDeprecatedProtocol = true;\n      data = upgradeMessage(data);\n    }\n\n    if (!this.#validateReceivedMessage?.(data)) {\n      return;\n    }\n\n    if (!this.#isAllowedOrigin(origin)) {\n      this.#log?.(\n        `Received a message from origin \\`${origin}\\` which did not match ` +\n          `allowed origins \\`[${this.#allowedOrigins.join(', ')}]\\``\n      );\n      return;\n    }\n\n    if (isSynMessage(data)) {\n      // If we receive a SYN message and already have a port, it means\n      // the child is re-connecting, in which case we'll receive a new port.\n      // For this reason, we always make sure we destroy the existing port.\n      this.#destroyPort();\n      this.#concreteRemoteOrigin = origin;\n    }\n\n    if (\n      isAck2Message(data) &&\n      // Previous versions of Penpal don't use MessagePorts and do all\n      // communication through the window.\n      !this.#isChildUsingDeprecatedProtocol\n    ) {\n      this.#port = ports[0];\n\n      if (!this.#port) {\n        throw new PenpalBugError('No port received on ACK2');\n      }\n\n      this.#port.addEventListener('message', this.#handleMessageFromPort);\n      this.#port.start();\n    }\n\n    for (const callback of this.#messageCallbacks) {\n      callback(data);\n    }\n  };\n\n  #handleMessageFromPort = ({ data }: MessageEvent): void => {\n    // Unlike in _handleMessageFromWindow, we don't need to check if\n    // the message is from a deprecated version of Penpal because older versions\n    // of Penpal don't use MessagePorts.\n    if (!this.#validateReceivedMessage?.(data)) {\n      return;\n    }\n\n    for (const callback of this.#messageCallbacks) {\n      callback(data);\n    }\n  };\n}\n\nexport default WindowMessenger;\n", "import { Message } from '../types.js';\nimport Messenger, {\n  InitializeMessengerOptions,\n  MessageHandler,\n} from './Messenger.js';\nimport { isAck2Message, isAck1Message, isSynMessage } from '../guards.js';\nimport PenpalError from '../PenpalError.js';\nimport PenpalBugError from '../PenpalBugError.js';\n\n// This is needed to resolve some conflict errors. There may be a better way.\ntype MessageTarget = Pick<\n  Worker,\n  'postMessage' | 'addEventListener' | 'removeEventListener'\n>;\n\ntype Options = {\n  /**\n   * The web worker receiving/sending communication from/to the parent window.\n   * If this messenger is being used within the worker, `worker` should\n   * typically be set to `self`.\n   */\n  worker: Worker | DedicatedWorkerGlobalScope;\n};\n\n/**\n * Handles the details of communicating with a child web worker.\n */\nclass WorkerMessenger implements Messenger {\n  #worker: MessageTarget;\n  #validateReceivedMessage?: (data: unknown) => data is Message;\n  #messageCallbacks = new Set<MessageHandler>();\n  #port?: MessagePort;\n\n  constructor({ worker }: Options) {\n    if (!worker) {\n      throw new PenpalError('INVALID_ARGUMENT', 'worker must be defined');\n    }\n\n    this.#worker = worker;\n  }\n\n  initialize = ({ validateReceivedMessage }: InitializeMessengerOptions) => {\n    this.#validateReceivedMessage = validateReceivedMessage;\n    this.#worker.addEventListener('message', this.#handleMessage);\n  };\n\n  sendMessage = (message: Message, transferables?: Transferable[]): void => {\n    if (isSynMessage(message) || isAck1Message(message)) {\n      this.#worker.postMessage(message, { transfer: transferables });\n      return;\n    }\n\n    if (isAck2Message(message)) {\n      const { port1, port2 } = new MessageChannel();\n      this.#port = port1;\n      port1.addEventListener('message', this.#handleMessage);\n      port1.start();\n\n      this.#worker.postMessage(message, {\n        transfer: [port2, ...(transferables || [])],\n      });\n      return;\n    }\n\n    if (this.#port) {\n      this.#port.postMessage(message, {\n        transfer: transferables,\n      });\n      return;\n    }\n\n    throw new PenpalBugError('Port is undefined');\n  };\n\n  addMessageHandler = (callback: MessageHandler): void => {\n    this.#messageCallbacks.add(callback);\n  };\n\n  removeMessageHandler = (callback: MessageHandler): void => {\n    this.#messageCallbacks.delete(callback);\n  };\n\n  destroy = () => {\n    this.#worker.removeEventListener('message', this.#handleMessage);\n    this.#destroyPort();\n    this.#messageCallbacks.clear();\n  };\n\n  #destroyPort = () => {\n    this.#port?.removeEventListener('message', this.#handleMessage);\n    this.#port?.close();\n    this.#port = undefined;\n  };\n\n  #handleMessage = ({ ports, data }: MessageEvent): void => {\n    if (!this.#validateReceivedMessage?.(data)) {\n      return;\n    }\n\n    if (isSynMessage(data)) {\n      // If we receive a SYN message and already have a port, it means\n      // the child is re-connecting, in which case we'll receive a new port.\n      // For this reason, we always make sure we destroy the existing port.\n      this.#destroyPort();\n    }\n\n    if (isAck2Message(data)) {\n      this.#port = ports[0];\n\n      if (!this.#port) {\n        throw new PenpalBugError('No port received on ACK2');\n      }\n\n      this.#port.addEventListener('message', this.#handleMessage);\n      this.#port.start();\n    }\n\n    for (const callback of this.#messageCallbacks) {\n      callback(data);\n    }\n  };\n}\n\nexport default WorkerMessenger;\n", "import { Message } from '../types.js';\nimport Messenger, {\n  InitializeMessengerOptions,\n  MessageHandler,\n} from './Messenger.js';\nimport PenpalError from '../PenpalError.js';\n\ntype Options = {\n  /**\n   * The port used to communicate to the other port of the port pair.\n   */\n  port: MessagePort;\n};\n\n/**\n * Handles the details of communicating on a MessagePort.\n */\nclass PortMessenger implements Messenger {\n  #port: MessagePort;\n  #validateReceivedMessage?: (data: unknown) => data is Message;\n  #messageCallbacks = new Set<MessageHandler>();\n\n  constructor({ port }: Options) {\n    if (!port) {\n      throw new PenpalError('INVALID_ARGUMENT', 'port must be defined');\n    }\n\n    this.#port = port;\n  }\n\n  initialize = ({ validateReceivedMessage }: InitializeMessengerOptions) => {\n    this.#validateReceivedMessage = validateReceivedMessage;\n    this.#port.addEventListener('message', this.#handleMessage);\n    this.#port.start();\n  };\n\n  sendMessage = (message: Message, transferables?: Transferable[]): void => {\n    this.#port?.postMessage(message, {\n      transfer: transferables,\n    });\n  };\n\n  addMessageHandler = (callback: MessageHandler): void => {\n    this.#messageCallbacks.add(callback);\n  };\n\n  removeMessageHandler = (callback: MessageHandler): void => {\n    this.#messageCallbacks.delete(callback);\n  };\n\n  destroy = () => {\n    this.#port.removeEventListener('message', this.#handleMessage);\n    this.#port.close();\n    this.#messageCallbacks.clear();\n  };\n\n  #handleMessage = ({ data }: MessageEvent): void => {\n    if (!this.#validateReceivedMessage?.(data)) {\n      return;\n    }\n\n    for (const callback of this.#messageCallbacks) {\n      callback(data);\n    }\n  };\n}\n\nexport default PortMessenger;\n", "// Not intended to be used internally. Can be useful externally\n// in projects not using TypeScript. It has the `Obj` suffix to disambiguate\n// it from the ErrorCode string union.\nconst ErrorCodeObj = {\n  ConnectionDestroyed: 'CONNECTION_DESTROYED',\n  ConnectionTimeout: 'CONNECTION_TIMEOUT',\n  InvalidArgument: 'INVALID_ARGUMENT',\n  MethodCallTimeout: 'METHOD_CALL_TIMEOUT',\n  MethodNotFound: 'METHOD_NOT_FOUND',\n  TransmissionFailed: 'TRANSMISSION_FAILED',\n} as const;\n\nexport default ErrorCodeObj;\n", "import { Log } from './types.js';\n\nconst debug = (prefix?: string): Log => {\n  return (...args: unknown[]) => {\n    console.log(`✍️ %c${prefix}%c`, 'font-weight: bold;', '', ...args);\n  };\n};\n\nexport default debug;\n"],
  "mappings": "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",
  "names": ["brand"]
}
